 ## Решение
 
1. Сначала событийный цикл выполнит задачу. В данном случае скрипт. В процессе выполнения будет выведен первый лог; начинается выполнение тела промиса, таймаут в коллбеке промиса уходит в очередь задач (но сначала в WebAPI), создается микрозадача, ожидающая выполнение resolve, находящегося в таймауте; второй таймаут и имидиате (8,9) также кидаются в WebAPI, а потом в очередь задач, так как задержка 0.  Next tick уходит в очередь next tick. А microtaskqueue  кидает коллбек в очередь микрозадач. Выполняется последняя часть задачи - лог (3).
2. Выполняется next tick queue. Там уже лежит коллбек из process.nextTick, так что будет лог (4)
3. Выполняется очередь микрозадач. Там лежит коллбек microtaskqueue, лог (5)
4. Выполняется следующая задача из очереди задач. Так как у  setTimeout из промиса ожидание в 0 секунд, выполнится он, лог (6) и resolve
5. Выполняется next tick очередь. В ней ничего нет, так что переходим к следующему шагу
6. Выполняется очередь микрозадач. Выполняется микрозадача, ожидавшая resolve промиса и выполянется Promise.then. Выводится лог (7)
7. Выполняется следующая задача из очереди задач. В этот раз setImmediate, так как он шел с крипте после таймаута с нулевой задержкой, в очередь задач он попал вторым. Лог (8)
8. Продолжается цикл событий - задача - очередь next tick задач - микрозадачи. WebAPI ждет 1 секунду на таймауте (9), так что его в очереди пока нет
9. По прошествии секунды с момента добавления в WebAPI (9) таймаута, он попадает в очередь задач и выполняется.


NB: Возможно в таймерах используется не WebAPI, а NodeAPI, так как документация говорит все же о том, что API таймеров "similar as the timers API provided by Web Browsers", что намекает, что API тут отдельный. microTask queue же это функция V8, а не самого Node, так что тут WebAPI